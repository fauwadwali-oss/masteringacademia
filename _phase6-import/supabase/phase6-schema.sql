-- ============================================
-- Phase 6: Search Monitor & Citation Chaining
-- ============================================

-- ============================================
-- SEARCH MONITOR
-- ============================================

-- Saved searches for monitoring
CREATE TABLE IF NOT EXISTS search_monitors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Search definition
  name TEXT NOT NULL,
  query TEXT NOT NULL,
  filters JSONB DEFAULT '{}',
  
  -- Schedule
  frequency TEXT CHECK (frequency IN ('daily', 'weekly', 'monthly')) DEFAULT 'weekly',
  is_active BOOLEAN DEFAULT true,
  
  -- Notification settings
  notify_email BOOLEAN DEFAULT false,
  notify_in_app BOOLEAN DEFAULT true,
  email_address TEXT,
  
  -- Stats
  last_checked_at TIMESTAMPTZ,
  last_new_count INTEGER DEFAULT 0,
  total_results INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Papers seen by each monitor (to track new vs old)
CREATE TABLE IF NOT EXISTS monitor_seen_papers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  monitor_id UUID NOT NULL REFERENCES search_monitors(id) ON DELETE CASCADE,
  
  -- Paper identification
  openalex_id TEXT NOT NULL,
  doi TEXT,
  title TEXT,
  
  -- When first seen
  first_seen_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(monitor_id, openalex_id)
);

-- Alerts generated by monitors
CREATE TABLE IF NOT EXISTS monitor_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  monitor_id UUID NOT NULL REFERENCES search_monitors(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Alert content
  new_paper_count INTEGER NOT NULL,
  paper_ids TEXT[], -- OpenAlex IDs of new papers
  
  -- Status
  is_read BOOLEAN DEFAULT false,
  is_dismissed BOOLEAN DEFAULT false,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_monitors_user ON search_monitors(user_id);
CREATE INDEX IF NOT EXISTS idx_monitors_active ON search_monitors(is_active, frequency);
CREATE INDEX IF NOT EXISTS idx_seen_papers_monitor ON monitor_seen_papers(monitor_id);
CREATE INDEX IF NOT EXISTS idx_alerts_user ON monitor_alerts(user_id, is_read);

-- Function to check if paper is new
CREATE OR REPLACE FUNCTION is_paper_new(
  p_monitor_id UUID,
  p_openalex_id TEXT
) RETURNS BOOLEAN AS $$
BEGIN
  RETURN NOT EXISTS (
    SELECT 1 FROM monitor_seen_papers 
    WHERE monitor_id = p_monitor_id AND openalex_id = p_openalex_id
  );
END;
$$ LANGUAGE plpgsql;

-- Function to mark papers as seen
CREATE OR REPLACE FUNCTION mark_papers_seen(
  p_monitor_id UUID,
  p_papers JSONB -- Array of {openalex_id, doi, title}
) RETURNS INTEGER AS $$
DECLARE
  paper JSONB;
  inserted_count INTEGER := 0;
BEGIN
  FOR paper IN SELECT * FROM jsonb_array_elements(p_papers)
  LOOP
    INSERT INTO monitor_seen_papers (monitor_id, openalex_id, doi, title)
    VALUES (
      p_monitor_id,
      paper->>'openalex_id',
      paper->>'doi',
      paper->>'title'
    )
    ON CONFLICT (monitor_id, openalex_id) DO NOTHING;
    
    IF FOUND THEN
      inserted_count := inserted_count + 1;
    END IF;
  END LOOP;
  
  RETURN inserted_count;
END;
$$ LANGUAGE plpgsql;

-- Function to get monitors due for checking
CREATE OR REPLACE FUNCTION get_monitors_due_for_check()
RETURNS TABLE (
  id UUID,
  user_id UUID,
  name TEXT,
  query TEXT,
  filters JSONB,
  email_address TEXT,
  notify_email BOOLEAN,
  notify_in_app BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    sm.id,
    sm.user_id,
    sm.name,
    sm.query,
    sm.filters,
    sm.email_address,
    sm.notify_email,
    sm.notify_in_app
  FROM search_monitors sm
  WHERE sm.is_active = true
    AND (
      -- Daily: not checked in last 23 hours
      (sm.frequency = 'daily' AND (sm.last_checked_at IS NULL OR sm.last_checked_at < NOW() - INTERVAL '23 hours'))
      -- Weekly: not checked in last 6.5 days
      OR (sm.frequency = 'weekly' AND (sm.last_checked_at IS NULL OR sm.last_checked_at < NOW() - INTERVAL '6.5 days'))
      -- Monthly: not checked in last 29 days
      OR (sm.frequency = 'monthly' AND (sm.last_checked_at IS NULL OR sm.last_checked_at < NOW() - INTERVAL '29 days'))
    );
END;
$$ LANGUAGE plpgsql;

-- Trigger to update timestamp
CREATE OR REPLACE FUNCTION update_monitor_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_monitor_update
  BEFORE UPDATE ON search_monitors
  FOR EACH ROW
  EXECUTE FUNCTION update_monitor_timestamp();

-- ============================================
-- CITATION CHAINING
-- ============================================

-- Citation chain sessions
CREATE TABLE IF NOT EXISTS citation_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Session info
  name TEXT,
  
  -- Seed paper
  seed_openalex_id TEXT NOT NULL,
  seed_doi TEXT,
  seed_title TEXT,
  seed_authors TEXT[],
  seed_year INTEGER,
  
  -- Stats
  forward_count INTEGER DEFAULT 0,
  backward_count INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Papers collected via citation chaining
CREATE TABLE IF NOT EXISTS citation_papers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES citation_sessions(id) ON DELETE CASCADE,
  
  -- Paper info
  openalex_id TEXT NOT NULL,
  doi TEXT,
  title TEXT NOT NULL,
  authors TEXT[],
  year INTEGER,
  journal TEXT,
  citation_count INTEGER DEFAULT 0,
  
  -- Chain info
  direction TEXT CHECK (direction IN ('forward', 'backward')) NOT NULL,
  depth INTEGER DEFAULT 1, -- 1 = direct citation, 2 = citation of citation, etc.
  parent_openalex_id TEXT, -- The paper this was found from
  
  -- Selection status
  is_selected BOOLEAN DEFAULT false,
  
  added_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(session_id, openalex_id)
);

-- Chain history (breadcrumb trail)
CREATE TABLE IF NOT EXISTS citation_chain_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES citation_sessions(id) ON DELETE CASCADE,
  
  openalex_id TEXT NOT NULL,
  title TEXT,
  position INTEGER NOT NULL, -- Order in the chain
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_citation_sessions_user ON citation_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_citation_papers_session ON citation_papers(session_id);
CREATE INDEX IF NOT EXISTS idx_citation_papers_direction ON citation_papers(session_id, direction);
CREATE INDEX IF NOT EXISTS idx_citation_history_session ON citation_chain_history(session_id, position);

-- Function to get citation stats
CREATE OR REPLACE FUNCTION get_citation_stats(p_session_id UUID)
RETURNS TABLE (
  total_papers INTEGER,
  forward_papers INTEGER,
  backward_papers INTEGER,
  selected_papers INTEGER,
  unique_journals INTEGER,
  year_range TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*)::INTEGER as total_papers,
    COUNT(*) FILTER (WHERE direction = 'forward')::INTEGER as forward_papers,
    COUNT(*) FILTER (WHERE direction = 'backward')::INTEGER as backward_papers,
    COUNT(*) FILTER (WHERE is_selected)::INTEGER as selected_papers,
    COUNT(DISTINCT journal)::INTEGER as unique_journals,
    CONCAT(MIN(year), '-', MAX(year)) as year_range
  FROM citation_papers
  WHERE session_id = p_session_id;
END;
$$ LANGUAGE plpgsql;

-- Function to export citations
CREATE OR REPLACE FUNCTION export_citations(
  p_session_id UUID,
  p_direction TEXT DEFAULT NULL, -- NULL = both
  p_selected_only BOOLEAN DEFAULT false
)
RETURNS TABLE (
  title TEXT,
  authors TEXT,
  year INTEGER,
  journal TEXT,
  doi TEXT,
  citation_count INTEGER,
  direction TEXT,
  depth INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    cp.title,
    array_to_string(cp.authors, '; '),
    cp.year,
    cp.journal,
    cp.doi,
    cp.citation_count,
    cp.direction,
    cp.depth
  FROM citation_papers cp
  WHERE cp.session_id = p_session_id
    AND (p_direction IS NULL OR cp.direction = p_direction)
    AND (NOT p_selected_only OR cp.is_selected = true)
  ORDER BY cp.direction, cp.citation_count DESC;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- RLS Policies
-- ============================================

ALTER TABLE search_monitors ENABLE ROW LEVEL SECURITY;
ALTER TABLE monitor_seen_papers ENABLE ROW LEVEL SECURITY;
ALTER TABLE monitor_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE citation_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE citation_papers ENABLE ROW LEVEL SECURITY;
ALTER TABLE citation_chain_history ENABLE ROW LEVEL SECURITY;

-- Search monitors
CREATE POLICY monitors_user_policy ON search_monitors
  FOR ALL USING (user_id = auth.uid() OR user_id IS NULL);

CREATE POLICY seen_papers_policy ON monitor_seen_papers
  FOR ALL USING (
    monitor_id IN (SELECT id FROM search_monitors WHERE user_id = auth.uid() OR user_id IS NULL)
  );

CREATE POLICY alerts_policy ON monitor_alerts
  FOR ALL USING (user_id = auth.uid() OR user_id IS NULL);

-- Citation chaining
CREATE POLICY citation_sessions_policy ON citation_sessions
  FOR ALL USING (user_id = auth.uid() OR user_id IS NULL);

CREATE POLICY citation_papers_policy ON citation_papers
  FOR ALL USING (
    session_id IN (SELECT id FROM citation_sessions WHERE user_id = auth.uid() OR user_id IS NULL)
  );

CREATE POLICY citation_history_policy ON citation_chain_history
  FOR ALL USING (
    session_id IN (SELECT id FROM citation_sessions WHERE user_id = auth.uid() OR user_id IS NULL)
  );

-- ============================================
-- Background Job Support (for scheduled checks)
-- ============================================

-- Queue table for background processing
CREATE TABLE IF NOT EXISTS monitor_check_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  monitor_id UUID NOT NULL REFERENCES search_monitors(id) ON DELETE CASCADE,
  scheduled_for TIMESTAMPTZ NOT NULL,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  status TEXT CHECK (status IN ('pending', 'processing', 'completed', 'failed')) DEFAULT 'pending',
  error_message TEXT,
  new_papers_found INTEGER,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_queue_pending ON monitor_check_queue(status, scheduled_for)
  WHERE status = 'pending';

-- Function to schedule monitor checks
CREATE OR REPLACE FUNCTION schedule_monitor_checks()
RETURNS INTEGER AS $$
DECLARE
  monitor RECORD;
  scheduled_count INTEGER := 0;
BEGIN
  FOR monitor IN SELECT * FROM get_monitors_due_for_check()
  LOOP
    INSERT INTO monitor_check_queue (monitor_id, scheduled_for)
    VALUES (monitor.id, NOW())
    ON CONFLICT DO NOTHING;
    scheduled_count := scheduled_count + 1;
  END LOOP;
  
  RETURN scheduled_count;
END;
$$ LANGUAGE plpgsql;
